/** ***********************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
************************************************************************ */

/*
 *  Package: @aemforms/af-formatters
 *  Version: 0.22.150
 */
const e = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvV]{1,5}|[zZOvVxX]{1,3}|S{1,3}|'(?:[^']|'')*')|[^a-zA-Z']+/g; const t = ['full', 'long', 'medium', 'short']; function n(e, n) { if (t.find(((t) => e.includes(t)))) { const t = r(e, n); const a = []; const i = { month: 'M', year: 'Y', day: 'd' }; return t.forEach((([e, t, n]) => { e in i ? a.push(Array(n).fill(i[e]).join('')) : e === 'literal' && a.push(t); })), a.join(''); } return e; } function r(e, t) {
  const n = {}; const r = e.split(/\s/).filter(((e) => e.length)); n.dateStyle = r[0], r.length > 1 && (n.timeStyle = r[1]); const a = new Date(2e3, 2, 1, 2, 3, 4); const i = new Intl.DateTimeFormat(t, n).formatToParts(a); const o = i.find(((e) => e.type === 'month')).value; const s = new Intl.DateTimeFormat(t, { month: 'long' }).formatToParts(a)[0].value; const u = new Intl.DateTimeFormat(t, { month: 'short' }).formatToParts(a)[0].value; const c = []; return i.forEach((({ type: t, value: n }) => {
    let r; t === 'month' && (r = {
      [o]: e === 'medium' ? 'short' : 'long', [s]: 'long', [u]: 'short', '03': '2-digit', 3: 'numeric',
    }[n]), t === 'year' && (r = { 2e3: 'numeric', '00': '2-digit' }[n]), ['day', 'hour', 'minute', 'second'].includes(t) && (r = n.length === 2 ? '2-digit' : 'numeric'), t === 'literal' && (r = n), t === 'dayPeriod' && (r = 'short'), c.push([t, r, n.length]);
  })), c;
} function a(n, a) { if (t.find(((e) => n.includes(e)))) return r(n, a); const i = []; return n.replace(e, ((e) => { const t = e.length; switch (e[0]) { case 'G': i.push(['era', t === 4 ? 'long' : t === 5 ? 'narrow' : 'short', t]); break; case 'y': i.push(['year', t === 2 ? '2-digit' : 'numeric', t]); break; case 'Y': case 'u': case 'U': case 'r': throw new RangeError('`Y/u/U/r` (year) patterns are not supported, use `y` instead'); case 'q': case 'Q': throw new RangeError('`q/Q` (quarter) patterns are not supported'); case 'M': case 'L': i.push(['month', ['numeric', '2-digit', 'short', 'long', 'narrow'][t - 1], t]); break; case 'w': case 'W': throw new RangeError('`w/W` (week) patterns are not supported'); case 'd': i.push(['day', ['numeric', '2-digit'][t - 1], t]); break; case 'D': case 'F': case 'g': throw new RangeError('`D/F/g` (day) patterns are not supported, use `d` instead'); case 'E': i.push(['weekday', ['short', 'short', 'short', 'long', 'narrow', 'narrow'][t - 1], t]); break; case 'e': if (t < 4) throw new RangeError('`e..eee` (weekday) patterns are not supported'); i.push(['weekday', ['short', 'long', 'narrow', 'short'][t - 4], t]); break; case 'c': if (t < 3 || t > 5) throw new RangeError('`c, cc, cccccc` (weekday) patterns are not supported'); i.push(['weekday', ['short', 'long', 'narrow', 'short'][t - 3], t]); break; case 'a': i.push(['hour12', !0, 1]); break; case 'b': case 'B': throw new RangeError('`b/B` (period) patterns are not supported, use `a` instead'); case 'h': i.push(['hourCycle', 'h12']), i.push(['hour', ['numeric', '2-digit'][t - 1], t]); break; case 'H': i.push(['hourCycle', 'h23', 1]), i.push(['hour', ['numeric', '2-digit'][t - 1], t]); break; case 'K': i.push(['hourCycle', 'h11', 1]), i.push(['hour', ['numeric', '2-digit'][t - 1], t]); break; case 'k': i.push(['hourCycle', 'h24', 1]), i.push(['hour', ['numeric', '2-digit'][t - 1], t]); break; case 'j': case 'J': case 'C': throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead'); case 'm': i.push(['minute', ['numeric', '2-digit'][t - 1], t]); break; case 's': i.push(['second', ['numeric', '2-digit'][t - 1], t]); break; case 'S': i.push(['fractionalSecondDigits', t, t]); break; case 'A': throw new RangeError('`S/A` (millisecond) patterns are not supported, use `s` instead'); case 'O': i.push(['timeZoneName', t < 4 ? 'shortOffset' : 'longOffset', t]), i.push(['x-timeZoneName', t < 4 ? 'O' : 'OOOO', t]); break; case 'X': case 'x': case 'Z': i.push(['timeZoneName', 'longOffset', 1]), i.push(['x-timeZoneName', e, 1]); break; case 'z': case 'v': case 'V': throw new RangeError('z/v/V` (timeZone) patterns are not supported, use `X/x/Z/O` instead'); case "'": i.push(['literal', e.slice(1, -1).replace(/''/g, "'"), -1]); break; default: i.push(['literal', e, -1]); } return ''; })), i; } const i = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(((e) => new Date(2e3, e, 1))); function o(e, t) {
  return 60 * (function (e) {
    const t = new Date(); function n(e) { const t = e.replace(':', ' ').split(' '); return { day: parseInt(t[0]), hour: parseInt(t[1]), minute: parseInt(t[2]) }; } let r = t.toLocaleString('en-US', {
      timeZone: e, day: 'numeric', hour: 'numeric', minute: 'numeric', hourCycle: 'h23',
    }); const a = n(r); const i = n(r = t.toLocaleString('en-US', {
      day: 'numeric', hour: 'numeric', minute: 'numeric', hourCycle: 'h23',
    })); return 24 * a.day * 60 + 60 * a.hour + a.minute - (24 * i.day * 60 + 60 * i.hour + i.minute) - t.getTimezoneOffset();
  }(t)) * 1e3;
} function s(e, t) { if (e === null) return null; let n = e.getTime() - 60 * e.getTimezoneOffset() * 1e3; const r = (function (e, t) { let n; try { n = new Intl.DateTimeFormat('en-US', { timeZone: t, timeZoneName: 'longOffset' }).format(e); } catch (e) { return o(0, t); } const r = /GMT([+\-−])?(\d{1,2}):?(\d{0,2})?/.exec(n); if (!r) return 0; const [a, i, s] = r.slice(1); const u = 60 * (60 * (isNaN(parseInt(i)) ? 0 : parseInt(i)) + (isNaN(parseInt(s)) ? 0 : parseInt(s))) * 1e3; return a === '-' ? -u : u; }(e, t)); return o(0, t), n += -r, new Date(n); } function u(e) { return e === null ? 0 : e.getTime() / 864e5; } function c(e) { return new Date(Math.round(1e3 * e * 60 * 60 * 24)); } function l(e, n, r, i) { if (r.startsWith('date|') && (r = r.split('|')[1]), t.find(((e) => r.includes(e)))) { const a = { timeZone: i }; const o = r.split(/\s/).filter(((e) => e.length)); return t.indexOf(o[0]) > -1 && (a.dateStyle = o[0]), o.length > 1 && t.indexOf(o[1]) > -1 && (a.timeStyle = o[1]), new Intl.DateTimeFormat(n, a).format(e); } const o = (function (e, t, n, r) { const i = a(n, t); i.push(['timeZone', r]); const o = i.filter(((e) => !e[0].startsWith('x-'))); const s = i.filter(((e) => e[0].startsWith('x-'))); const u = Object.fromEntries(o); delete u.literal; const c = new Intl.DateTimeFormat(t, u).formatToParts(e); return (function (e, t) { ['hour', 'minute', 'second'].forEach(((n) => { const r = e.find(((e) => e.type === n)); if (!r) return; const a = t.find(((e) => e[0] === n))[1]; a === '2-digit' && r.value.length === 1 && (r.value = `0${r.value}`), a === 'numeric' && r.value.length === 2 && r.value.charAt(0) === '0' && (r.value = r.value.slice(1)); })); }(c, i)), (function (e, t) { const n = e.find(((e) => e.type === 'year')); if (!n) return; const r = t.find(((e) => e[0] === 'year'))[2]; for (;n.value.length < r;)n.value = `0${n.value}`; }(c, o)), o.reduce(((e, t) => { if (t[0] === 'literal')e.push(t); else { const n = c.find(((e) => { return e.type === ({ hour12: 'dayPeriod', fractionalSecondDigits: 'fractionalSecond' }[n = t[0]] || n); let n; })); if (n && n.type === 'timeZoneName') { const e = s.find(((e) => e[0] === 'x-timeZoneName'))[1]; const t = e[0]; t === 'Z' && (e.length < 4 ? (n.value = n.value.replace(/(GMT|:)/g, ''), n.value === '' && (n.value = '+0000')) : e.length === 5 && (n.value === 'GMT' ? n.value = 'Z' : n.value = n.value.replace(/GMT/, ''))), t === 'X' || t === 'x' ? (e.length === 1 && (n.value = n.value.replace(/(GMT|:(00)?)/g, '')), e.length === 2 && (n.value = n.value.replace(/(GMT|:)/g, '')), e.length === 3 && (n.value = n.value.replace(/GMT/g, '')), t === 'X' && n.value === '' && (n.value = 'Z')) : e === 'O' && (n.value = n.value.replace(/GMT/g, '').replace(/0(\d+):/, '$1:').replace(/:00/, ''), n.value === '' && (n.value = '+0')); }n && e.push([n.type, n.value]); } return e; }), []); }(e, n, r, i)); return o.map(((e) => e[1])).join(''); } function m(e, t, n, r, o = !1) {
  n.startsWith('date|') && (n = n.split('|')[1]); const u = []; const c = []; const l = (function (e) { const t = new Intl.DateTimeFormat(e, { era: 'short' }).formatToParts(new Date()); const n = t.find(((e) => e.type === 'era'))?.value; return n === 'هـ' ? 'islamic' : 'gregory'; }(t)); const m = (h = t, new Intl.NumberFormat(h, { style: 'decimal', useGrouping: !1 }).format(9876543210).split('').reverse()); let h; const p = `([${m[0]}-${m[9]}]{1,2})`; const d = `([${m[0]}-${m[9]}]{1,3})`; const g = `([${m[0]}-${m[9]}]{1,4})`; let f = 'h12'; let y = o; let w = !1; const b = (e) => D(e) - 1; const D = (e) => e.split('').reduce(((e, t) => 10 * e + m.indexOf(t)), 0); const v = a(n, t); const k = (function (e, t) { return i.map(((n) => { const r = new Intl.DateTimeFormat(e, t).formatToParts(n).find(((e) => e.type === 'month')); return r && r.value; })); }(t, Object.fromEntries(v))); v.forEach((([e, n, r]) => { if (e === 'literal')c.push(n); else if (e === 'month' && ['numeric', '2-digit'].includes(n))c.push(p), u.push(['month', b]); else if (e === 'month' && ['formatted', 'long', 'short', 'narrow'].includes(n))c.push(`(${k.join('|')})`), u.push(['month', (i = k, (e) => i.indexOf(e))]); else if (['day', 'minute', 'second'].includes(e))e !== 'minute' && e !== 'second' || (y = !1), c.push(p), u.push([e, D]); else if (e === 'fractionalSecondDigits')y = !1, c.push(d), u.push([e, (e, t) => t.fractionalSecondDigits + D(e)]); else if (e === 'hour')y = !1, c.push(p), u.push([e, (e, t) => t.hour + D(e)]); else if (e === 'year')c.push(n === 'numeric' ? g : p), u.push(['year', (a = r, (e) => { let t = D(e); return t = t < 100 && a === 2 ? t + 2e3 : t, l === 'islamic' && (t = Math.ceil(0.97 * t + 622)), a > 2 && t < 100 && (w = !0), t; })]); else if (e === 'dayPeriod') { y = !1; const e = (function (e) { const t = new Date(2e3, 1, 1, 1, 1, 1); const n = new Date(2e3, 1, 1, 16, 1, 1); const r = new Intl.DateTimeFormat(e, { dateStyle: 'full', timeStyle: 'full' }); const a = r.formatToParts(t).find(((e) => e.type === 'dayPeriod')); const i = r.formatToParts(n).find(((e) => e.type === 'dayPeriod')); return a && i ? { regex: `(${a.value}|${i.value})`, fn: (e, t) => t.hour += e === i.value ? 12 : 0 } : null; }(t)); e && (c.push(e.regex), u.push(['hour', e.fn])); } else e === 'hourCycle' ? (y = !1, f = n) : e === 'x-timeZoneName' ? (y = !1, c.push('(?:GMT|UTC|Z)?([+\\-−0-9]{0,3}:?[0-9]{0,2})'), u.push([e, (e, t) => { if (y = !0, !e) return; const n = e.replace(/−/, '-').match(/([+\-\d]{2,3}):?(\d{0,2})/); const r = 1 * n[1]; t.hour -= r; const a = n.length > 2 ? 1 * n[2] : 0; t.minute -= r < 0 ? -a : a; }])) : e !== 'timeZoneName' && (y = !1, c.push('.+?')); let a; let i; return c; }), []); const S = new RegExp(`^${c.join('')}$`); const T = e.match(S); if (T === null) return null; const E = {
    year: 1972, month: 0, day: 1, hour: 0, minute: 0, second: 0, fractionalSecondDigits: 0,
  }; if (T.slice(1).forEach(((e, t) => { const [n, r] = u[t]; E[n] = r(e, E); })), f === 'h24' && E.hour === 24 && (E.hour = 0), f === 'h12' && E.hour === 12 && (E.hour = 0), y) { const e = new Date(Date.UTC(E.year, E.month, E.day, E.hour, E.minute, E.second, E.fractionalSecondDigits)); return w && e.setUTCFullYear(E.year), e; } const x = new Date(E.year, E.month, E.day, E.hour, E.minute, E.second, E.fractionalSecondDigits); return w && x.setFullYear(E.year), r == null ? x : s(x, r);
} function h(e, t, n) { return m(e, t, 'yyyy-MM-dd', null, n); } const p = {
  'da-DK': 'DKK', 'de-DE': 'EUR', 'en-US': 'USD', 'en-GB': 'GBP', 'es-ES': 'EUR', 'fi-FI': 'EUR', 'fr-FR': 'EUR', 'it-IT': 'EUR', 'ja-JP': 'JPY', 'nb-NO': 'NOK', 'nl-NL': 'EUR', 'pt-BR': 'BRL', 'sv-SE': 'SEK', 'zh-CN': 'CNY', 'zh-TW': 'TWD', 'ko-KR': 'KRW', 'cs-CZ': 'CZK', 'pl-PL': 'PLN', 'ru-RU': 'RUB', 'tr-TR': 'TRY',
}; const d = Object.keys(p); const g = function (e) { if (d.indexOf(e) > -1) return p[e]; { const t = d.find(((t) => t.startsWith(e))); if (t) return p[t]; } return ''; }; const f = /(?:[#]+|[@]+(#+)?|[0]+|[,]|[.]|[-]|[+]|[%]|[¤]{1,4}(?:\/([a-zA-Z]{3}))?|[;]|[K]{1,2}|E{1,2}[+]?|'(?:[^']|'')*')|[^a-zA-Z']+/g; const y = ['acre', 'bit', 'byte', 'celsius', 'centimeter', 'day', 'degree', 'fahrenheit', 'fluid-ounce', 'foot', 'gallon', 'gigabit', 'gigabyte', 'gram', 'hectare', 'hour', 'inch', 'kilobit', 'kilobyte', 'kilogram', 'kilometer', 'liter', 'megabit', 'megabyte', 'meter', 'mile', 'mile-scandinavian', 'milliliter', 'millimeter', 'millisecond', 'minute', 'month', 'ounce', 'percent', 'petabyte', 'pound', 'second', 'stone', 'terabit', 'terabyte', 'week', 'yard', 'year'].join('|'); const w = [/^currency(?:\/([a-zA-Z]{3}))?$/, /^decimal$/, /^integer$/, /^percent$/, new RegExp(`^unit/(${y})$`)]; function b(e, t) { const n = {}; const r = []; let a; let i; for (i = 0; i < w.length && a == null; i++)a = w[i].exec(e); if (a) { switch (i) { case 1: n.style = 'currency', n.currencyDisplay = 'narrowSymbol', a[1] ? n.currency = a[1] : n.currency = g(t); break; case 2: new Intl.NumberFormat(t, {}).resolvedOptions(), n.minimumFractionDigits = n.minimumFractionDigits || 2; break; case 3: n.minimumFractionDigits = 0, n.maximumFractionDigits = 0; break; case 4: n.style = 'percent', n.maximumFractionDigits = 2; break; case 5: n.style = 'unit', n.unitDisplay = 'long', n.unit = a[1]; } return { options: n, order: r }; } return n.useGrouping = !1, n.minimumIntegerDigits = 1, n.maximumFractionDigits = 0, n.minimumFractionDigits = 0, e.replace(f, ((a, i, o, s) => { const u = a.length; switch (a[0]) { case '#': r.push(['digit', u]), !0 === n?.decimal && (n.maximumFractionDigits = n.minimumFractionDigits + u); break; case '@': if (n?.minimumSignificantDigits) throw '@ symbol should occur together'; const c = i || ''; r.push(['@', u - c.length]), n.minimumSignificantDigits = u - c.length, n.maximumSignificantDigits = u, r.push(['digit', c.length]); break; case ',': if (!0 === n?.decimal) throw 'grouping character not supporting for fractions'; r.push(['group', 1]), n.useGrouping = 'auto'; break; case '.': n?.decimal ? console.error('only one decimal symbol is allowed') : (r.push(['decimal', 1]), n.decimal = !0); break; case '0': if (r.push('0', u), n.minimumSignificantDigits || n.maximumSignificantDigits) throw '0 is not supported with @'; !0 === n?.decimal ? (n.minimumFractionDigits = u, n.maximumFractionDigits || (n.maximumFractionDigits = u)) : n.minimumIntegerDigits = u; break; case '-': s !== 0 && console.error('sign display is always in the beginning'), n.signDisplay = 'negative', r.push(['signDisplay', 1, '-']); break; case '+': s !== 0 && r[r.length - 1][0] === 'E' && console.error('sign display is always in the beginning'), s === 0 && (n.signDisplay = 'always'), r.push(['signDisplay', 1, '+']); break; case '¤': s !== 0 && s !== e.length - 1 ? console.error('currency display should be either in the beginning or at the end') : (n.style = 'currency', n.currencyDisplay = ['symbol', 'code', 'name', 'narrowSymbol'][u - 1], n.currency = o || g(t), r.push(['currency', u])); break; case '%': s !== 0 && s !== e.length - 1 ? console.error('percent display should be either in the beginning or at the end') : (r.push(['%', 1]), n.style = 'percent'); break; case 'E': r.push(['E', u]), n.style = ['scientific', 'engineering'](u - 1); break; default: console.error(`unknown chars${a}`); } })), { options: n, order: r }; } function D(e, t, n) { if (n.startsWith('num|') && (n = n.split('|')[1]), !n) return e; t = t || 'en'; const { options: r, order: a } = b(n, t); return new Intl.NumberFormat(t, r).format(e); } function v(e, t, n) { try { n.startsWith('num|') && (n = n.split('|')[1]); let r = 1; let a = e; const i = (function (e, t) { const n = {}; let r = new Intl.NumberFormat(e, { style: 'decimal', useGrouping: !1 }).formatToParts(9876543210.1); n.digits = r.find(((e) => e.type === 'integer')).value.split('').reverse(), n.decimal = r.find(((e) => e.type === 'decimal')).value; const a = (e) => { const t = r.find(((t) => t.type === e)); t && (n[e] = t.value); }; const i = b(t); const o = new Intl.NumberFormat(e, i); return r = o.formatToParts(-987654321), a('group'), a('minusSign'), a('percentSign'), n.currency = r.filter(((e) => e.type === 'currency')).map(((e) => e.value)), n.literal = r.filter(((e) => e.type === 'literal')).map(((e) => e.value)), r = o.formatToParts(987654321), a('plusSign'), a('exponentSeparator'), a('unit'), n; }(t, n)); if (i.group && (a = a.replaceAll(i.group, '')), a = a.replace(i.decimal, '.'), i.unit && (a = a.replaceAll(i.unit, '')), i.minusSign && a.includes(i.minusSign) && (a = a.replace(i.minusSign, ''), r *= -1), i.percentSign && a.includes(i.percentSign) && (r /= 100, a = a.replace(i.percentSign, '')), i.currency.forEach(((e) => a = a.replace(e, ''))), i.literal.forEach(((e) => { a.includes(e) && (e === '(' && (r *= -1), a = a.replace(e, '')); })), i.plusSign && (a = a.replace(i.plusSign, '')), i.exponentSeparator) { let e; [a, e] = a.split(i.exponentSeparator), r *= 10 ** e; } const o = r * a; return isNaN(o) ? e : o; } catch (t) { return console.dir(t), e; } } const k = function (e) { const t = e?.match(/^(?:(num|date)\|)?(.+)/); return [t?.[1], t?.[2]]; }; const S = function (e, t, n, r) { const [a, i] = k(n); switch (a) { case 'date': return e instanceof Date || (e = new Date(e.replace(/-/g, '/').replace(/T.+/, ''))), l(e, t, i, r); case 'num': return D(e, t, i); default: throw 'unable to deduce the format. The skeleton should be date|<format> for date formats and num|<format> for numbers'; } }; const T = function (e, t, n, r) { const [a, i] = k(n); switch (a) { case 'date': return m(e, t, i, r); case 'number': return v(e, t, i); default: throw 'unable to deduce the format. The skeleton should be date|<format> for date formats and num|<format> for numbers'; } }; export {
  u as datetimeToNumber, S as format, l as formatDate, D as formatNumber, c as numberToDatetime, T as parse, m as parseDate, n as parseDateSkeleton, h as parseDefaultDate, v as parseNumber,
};
